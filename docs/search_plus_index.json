{"./":{"url":"./","title":"关于SmartSwipe","keywords":"","body":"关于SmartSwipe 库 smart-swipe smart-swipe-x smart-swipe-support 最新版 一个智能的Android侧滑处理框架，轻松实现各种侧滑效果 另外，为了便于使用，SmartSwipe中封装了以下工具类： SmartSwipeBack: 无需透明主题，无需继承某个特定的Activity，不需要侵入xml布局文件，也不需要侵入BaseActivity，全局只需一行代码即可搞定所有Activity侧滑返回可选样式：开门、百叶窗、仿微信、仿QQ及仿MIUI贝塞尔曲线 SmartSwipeRefresh: 一行代码实现下拉刷新和加载更多，支持纵向和横向 SwipeConsumerExclusiveGroup: 管理一组互斥的SwipeConsumer，同时最多只能打开一个，可用在RecyclerView等列表项中使用 演示 弹性拉伸样式StretchConsumer 弹性留白样式SpaceConsumer 滑动透明样式TranslucentSlidingConsumer 在上层显示的滑动抽屉DrawerConsumer 在下层显示的滑动抽屉(可设置联动系数)SlidingConsumer 开门样式DoorConsumer 百叶窗样式ShuttersConsumer 用于制作封面 开门样式 百叶窗样式 抽屉样式 用于实现Activity侧滑返回 无需透明主题，无需继承某个特定的Activity，不需要侵入xml布局文件，也不需要侵入BaseActivity，轻松搞定Activity侧滑返回 仿QQ侧滑返回StayConsumer 仿微信侧滑返回ActivitySlidingBackConsumer 仿MIUI系统侧滑返回BezierBackConsumer 开门样式ActivityDoorBackConsumer 百叶窗样式ActivityShuttersBackConsumer 全局使用SmartSwipeBack 使用方式 首先，添加 SmartSwipe 依赖到项目中 compile 'com.billy.android:smart-swipe:latestVersion' 由于主库未添加任何支持库，仅在android api >= 21(android 5.0以上)时才支持嵌套滑动效果(NestedScrolling)。 如需兼容5.0以下版本嵌套滑动，分别按照如下2种方式来兼容androidX或android support库： compile 'com.billy.android:smart-swipe:latestVersion' //android x环境下兼容NestedScrolling compile 'com.billy.android:smart-swipe-x:latestVersion' 或 compile 'com.billy.android:smart-swipe:latestVersion' //android support library环境下兼容NestedScrolling compile 'com.billy.android:smart-swipe-support:latestVersion' 开始使用 SmartSwipe中绝大多少的使用都可以通过链式编程在一行代码内完成，API的设计风格如下： SmartSwipe.wrap(...) //view or Activity .addConsumer(...) //添加consumer .enableDirection(...) //指定consumer接收哪个方向的侧滑事件 .setXxx(...) //[可选]一些其它设置项 .addListener(...); //[可选]给consumer添加监听 示例代码： //为控件添加仿MIUI的弹性拉伸效果： // 当纵向不能滚动（或滚动到顶/底）时，若继续拖动，则UI呈现弹性拉伸效果，释放后平滑恢复 SmartSwipe.wrap(view) .addConsumer(new StretchConsumer()) .enableVertical(); 可以为同一个View添加多个SwipeConsumer，按照添加的顺序消费侧滑事件。例如： SmartSwipe.wrap(view) .addConsumer(new StretchConsumer()) .enableVertical() //仿MIUI拉伸效果的方向为：上下2个方向 .addConsumer(new SpaceConsumer()) .enableHorizontal() //仿iOS弹性留白效果的方向为：左右2个方向 ; 每次侧滑，从开始到结束，只有被1个SwipeConsumer全程消费，谁先捕获到本次侧滑，则接下来的侧滑距离都交给它来消费。 点击这里你将了解到： 内置的每种SwipeConsumer的具体用法 创建一个属于你的自定义SwipeConsumer的方法 全局只需一行代码即可搞定所有Activity侧滑返回(5种样式可选) SmartSwipeBack.activityBezierBack(application, null); //仿小米MIUI系统的贝塞尔曲线返回效果 SmartSwipeBack.activityStayBack(application, null); //仿手机QQ的手势滑动返回 SmartSwipeBack.activitySlidingBack(application, null); //仿微信带联动效果的透明侧滑返回 SmartSwipeBack.activityDoorBack(application, null); //侧滑开门样式关闭activity SmartSwipeBack.activityShuttersBack(application, null); //侧滑百叶窗样式关闭activity 详细内容及注意事项请看这里：全局侧滑返回 一行代码给View添加下拉刷新功能 //xxxMode第二个参数为false，表示工作方向为纵向：下拉刷新&上拉加载更多 //如果第二个参数设置为true，则表示工作方向为横向：右拉刷新&左拉加载更多 SmartSwipeRefresh.drawerMode(view, false).setDataLoader(loader); SmartSwipeRefresh.behindMode(view, false).setDataLoader(loader); SmartSwipeRefresh.scaleMode(view, false).setDataLoader(loader); SmartSwipeRefresh.translateMode(view, false).setDataLoader(loader); 更多关于下拉刷新功能的介绍请查看下拉刷新 SmartSwipe特性： 支持上下左右4个方向侧滑 支持边缘触发侧滑也支持整个View(或整个Activity)区域内触发侧滑 支持给同一个控件添加多个侧滑效果 支持在View树的不同层级中嵌套使用 支持在ListView及RecyclerView等列表项及列表本身使用 支持NestedScroll（支持support和androidX） 支持通过代码触发侧滑 内置十多种SwipeConsumer侧滑效果（包括百叶窗、开门、滑动抽屉、下拉刷新、侧滑返回、侧滑删除等等） SmartSwipe封装了对控件侧滑事件（上/下/左/右4个方向滑动的手势事件）的捕获、分发及多点交替滑动的处理，基于SmartSwipe我们可以为控件添加各种你想要的侧滑效果。 主要实现原理及思想来源于android官方支持库中的ViewDragHelper，在其基础上，将它对子View的捕获及移动处理改成对父View自身触摸事件的定性（能否及是否捕获）、定向（捕获的事件所触发的侧滑方向）及定位（事件捕获之后在侧滑方向上移动的距离），并交由SwipeConsumer来完成侧滑事件的具体UI呈现效果 SwipeConsumer类实现了侧滑事件处理的公共逻辑，通过继承SwipeConsumer可以自定义各种丰富的侧滑效果。 SmartSwipe的封装思路： 用一个ViewGroup将需要处理侧滑事件的控件View包裹起来，被包裹起来的控件作为它的contentView，可以为这个ViewGroup添加一些附属控件View（如：滑动抽屉） 拦截这个ViewGroup的touch事件，并将touch事件转换为侧滑距离交给SwipeConsumer进行消费 SwipeConsumer在消费侧滑事件的过程中，对contentView及附属控件的UI呈现（位置、缩放、透明等）进行合理的加工，从而实现各种侧滑的效果。 鸣谢 实现侧滑返回功能Activity透明的方案参考了: Android侧滑返回分析和实现（不高仿微信） 源码：SwipeBackHelper ikew0ng/SwipeBackLayout Android 平台滑动返回库对比 Android版与微信Activity侧滑后退效果完全相同的SwipeBackLayout 实现贝塞尔曲线侧滑返回功能时参考了： Blankj/SwipePanel qinci/AndroidSlideBack 下拉刷新功能参考了scwang90/SmartRefreshLayout部分设计 Demo中的卡通头像均来自: https://www.thiswaifudoesnotexist.net/ Demo中使用icon图片均取自：https://www.iconfont.cn/ Demo中封面使用的图片来源于回车素材网（侵删） Demo中封面使用的下雪效果自定义View拷贝并修改自：AnliaLee/FallingView Demo中首页使用的点赞自定义View直接引用自第三方开源库：jd-alexander/LikeButton Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-14 14:49:11 "},"pages/SwipeConsumer.html":{"url":"pages/SwipeConsumer.html","title":"SwipeConsumer","keywords":"","body":"SwipeConsumer 作为所有具体Consumer的父类，SwipeConsumer本身是一个抽象类，其主要职能为： 对滑动事件的捕获、加工及传递等逻辑进行统一封装 对滑动方向是否启用、滑动方向是否锁定、滑动距离限制、自动滑动动画的插值器等一系列公共属性的处理并提供相应的设置API 工作流程 捕获侧滑事件 从静止状态开始侧滑: tryAcceptMoving, 返回true表示捕获 非静止状态开始侧滑: tryAcceptSettling, 返回true表示捕获 开始侧滑事件 onSwipeAccepted, 捕获到侧滑事件后，会立即回调 计算并消费滑动距离(0次或多次) 计算侧滑距离 clampDistanceHorizontal clampDistanceVertical 消费滑动距离 onDisplayDistanceChanged 手势释放事件(手势触发的侧滑才会产生手势释放事件) onSwipeReleased, 根据Release处理方式进行相应处理 已关闭/已打开 onOpened/onClosed 结束侧滑事件 如何自定义一个SwipeConsumer？ 新建一个类，继承SwipeConsumer [可选]在构造方法中进行一些初始化（需要context对象才能初始化的属性，可以放在onAttachToWrapper方法中初始化） [可选]如果有额外的捕获逻辑，可以重写父类的tryAcceptMoving和tryAcceptSettling方法 重写onSwipeAccepted方法，由于此时已经确定捕获了侧滑事件，并确定好了侧滑的方向(mDirection)，可以为本次侧滑事件做一些初始化工作 [可选]重写clampDistanceHorizontal及clampDistanceHorizontal方法，可在满足一定条件下才真正执行侧滑 重写onDisplayDistanceChanged方法，执行具体的侧滑的UI效果呈现 [可选]如果UI呈现效果中包含布局控件的移动，需要重写onLayout方法，在此方法中也要按照侧滑后的逻辑进行控件布局定位 重写onDetachFromWrapper方法，还原现场，移除当前consumer的所有改动痕迹 具体细节可参考内置的各种SwipeConsumer: DoorConsumer (开门：从中间向两边分开) ShuttersConsumer (百叶窗) DrawerConsumer (在上层显示滑动抽屉) SlidingConsumer (在下层显示可相对滑动的抽屉) SpaceConsumer (主体滑动后弹性留白) StayConsumer (滑动时主体保持不动，根据释放时的方向和速率来确定是否打开，可用于实现仿手机QQ的滑动返回效果) StretchConsumer (拉伸，仿MIUI中的拉伸效果) TranslucentSlidingConsumer (SpaceConsumer的进阶版，可实现侧滑删除的效果) BezierBackConsumer (贝塞尔曲线返回) ActivityDoorBackConsumer (Activity开门返回) ActivityShuttersBackConsumer (Activity百叶窗返回) ActivitySlidingBackConsumer (Activity透明侧滑返回) 更多侧滑效果等你来添加！ Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 14:20:41 "},"pages/consumers/common_settings.html":{"url":"pages/consumers/common_settings.html","title":"公共属性","keywords":"","body":"公共属性 SwipeConsumer作为所有consumer的基类，一些公共的设置属性将放在这个基类中进行设置及使用 1. 侧滑方向的启用与锁定 默认情况下，consumer未启用任何方向，必须至少启用一个方向consumer才会开始工作 默认情况下，consumer未锁定任何方向，被锁定的方向即使enable为true也不可被手势事件触发侧滑（用户无法拖动），但可通过代码执行侧滑事件。 变量名称 类型 取值范围 默认值 set方法 get方法 备注 mEnableDirection int 0~15 0 enableDirection(dir)enableLeft()enableRight()enableTop()enableBottom()enableHorizontal()enableVertical()enableAllDirections()disableDirection(dir)disableLeft()disableRight()disableTop()disableBottom()disableHorizontal()disableVertical()disableAllDirections() isDirectionEnable(dir)isLeftEnable()isRightEnable()isTopEnable()isBottomEnable()isHorizontalEnable()isVerticalEnable()isAllDirectionsEnable() 表示可侧滑的方向若disable的方向包含当前侧滑的方向，则会自动close重置。参考：侧滑方向 mLockDirection int 0~15 0 lockDirection(dir)lockLeft()lockRight()lockTop()lockBottom()lockHorizontal()lockVertical()lockAllDirections()unlockDirection(dir)unlockLeft()unlockRight()unlockTop()unlockBottom()unlockHorizontal()unlockVertical()unlockAllDirections() isDirectionLocked(dir)isLeftLocked()isRightLocked()isTopLocked()isBottomLocked()isHorizontalLocked()isVerticalLocked()isAllDirectionsLocked() 表示锁定的方向被锁定的方向即使enable为true也不可被手势事件触发侧滑，但可通过代码执行侧滑事件。参考：侧滑方向 2. 宽高 宽高属性指的是SmartSwipeWrapper的宽高尺寸 其初始值均为0，在onMeasure方法中分别被赋值为mWrapper.getMeasuredWidth()和mWrapper.getMeasuredHeight() Tips: 在onMeasure方法被调用前，通过consumer.setLeftOpen()、consumer.smoothTopOpen()等方法让SmartSwipe自动执行侧滑将不能生效。 如果SmartSwipeWrapper的宽高尺寸是确定值，可以提前为consumer设置宽高，从而实现在onMeasure方法被调用前执行自动侧滑的功能。demo中的封面演示了这种用法。 getter/setter均一一对应，不赘述 变量名称 类型 取值范围 默认值 备注 mWidth int >=0 0 SmartSwipeWrapper的宽度 mHeight int >=0 0 SmartSwipeWrapper的高度 3. 位移相关属性 getter/setter均一一对应，不赘述 变量名称 类型 取值范围 默认值 备注 mOpenDistance int >=0 20dp 从关闭状态到打开状态需要移动的像素值 mOverSwipeFactor float >=0F 0F 可以越界拖动的系数，越界的最大像素值为:mOpenDistance x mOverSwipeFactor可拖动的最大像素值为：mOpenDistance x (1 + mOverSwipeFactor) mSwipeDistanceCalculator SwipeDistanceCalculator - null 侧滑距离计算器，对拖动的距离进行加工后返回UI需要呈现的距离，用以实现与手势拖动不同步的效果，如阻力效果 mEdgeSize int >=0 0 在控件边缘处一定范围内才能触发若为0，表示在整个控件区域都可触发 mSensitivity float >0 1F 灵敏度，数值越大越灵敏 4. 几个开关 getter/setter都一一对应，不赘述 变量名称 类型 取值范围 默认值 备注 mDisableSwipeOnSettling boolean true/false false true表示在自动滑动过程中禁用手指触发侧滑 mDisableNestedScroll boolean true/false false true表示禁用手势拖动的NestedScroll触发侧滑 mDisableNestedFly boolean true/false false true表示禁用惯性滑动时的NestedScroll触发侧滑 5. 其它属性 getter/setter都一一对应，不赘述 变量名称 类型 取值范围 默认值 备注 mInterpolator Interpolator - SwipeHelper.sInterpolator 非手势事件拖动时动画侧滑的插值器 mReleaseMode int 0~7 1 释放模式决定了在用户拖动触发侧滑后抬起手指时的处理策略参考：Release处理方式 mTag Object 所有值 null 如果有需要，可以为consumer设置一个标签 6. 可以获取但不能设置的属性 变量名称 类型 获取方式 取值范围 备注 mWrapper SmartSwipeWrapper getWrapper() - 当前consumer所添加到的wrapper mSwipeHelper SwipeHelper getSwipeHelper() - 为当前consumer捕获触发侧滑的touch事件管理工具 - int getDragState() SwipeHelper.STATE_IDLESwipeHelper.STATE_DRAGGINGSwipeHelper.STATE_SETTLINGSwipeHelper.STATE_NONE_TOUCH 获取当前consumer的侧滑状态 mProgress float getProgress() 0 ~ 1 + mOverSwipeFactor 当前侧滑的进度，0为关闭状态，1为打开状态 mDirection int getDirection() 0/1/2/4/8 当前侧滑的方向，只会是：无、左、右、上、下这5个值中的一种 mSwiping boolean isSwiping() true/false 当前状态是否为：正在侧滑 7. 子类中可以使用的属性（不要修改） 变量名称 类型 备注 mSwipeOpenDistance int 从关闭状态到打开状态需要真实拖动的像素值(此值是经过mSwipeDistanceCalculator计算后的mOpenDistance) mSwipeMaxDistance int 最大拖动距离像素值，mSwipeMaxDistance = mSwipeOpenDistance * (1 + mOverSwipeFactor) mOpenDistanceSpecified boolean true代表mOpenDistance是通过setOpenDistance(distance)手动设置的子类可以用此值来判断是否需要设置默认值 mCurDisplayDistanceX int 当前UI需要呈现出X轴方向上移动的像素值（经过mSwipeDistanceCalculator计算后的值） mCurDisplayDistanceY int 当前UI需要呈现出Y轴方向上移动的像素值（经过mSwipeDistanceCalculator计算后的值） Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-12 14:56:16 "},"pages/consumers/SpaceConsumer.html":{"url":"pages/consumers/SpaceConsumer.html","title":"SpaceConsumer","keywords":"","body":"SpaceConsumer 滑动后弹性留白的一种UI效果，默认添加的侧滑距离计算器为new ScaledCalculator(0.5F) 效果如下图所示： 示例代码 SmartSwipe.wrap(view) .addConsumer(new SpaceConsumer()) .enableVertical(); 属性列表 继承自 SwipeConsumer，公共属性中的参数设置尽皆有效 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-11 19:44:36 "},"pages/consumers/StretchConsumer.html":{"url":"pages/consumers/StretchConsumer.html","title":"StretchConsumer","keywords":"","body":"StretchConsumer 滑动后弹性拉伸的一种UI效果，如下图所示： 示例代码 SmartSwipe.wrap(view) .addConsumer(new StretchConsumer()) .enableVertical(); 属性列表 继承自 SwipeConsumer，公共属性中的参数设置尽皆有效 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-11 19:44:40 "},"pages/consumers/DrawerConsumer.html":{"url":"pages/consumers/DrawerConsumer.html","title":"DrawerConsumer","keywords":"","body":"DrawerConsumer 抽屉效果，抽屉显示在被包裹的控件上层(即覆盖在contentView之上显示)，如下图所示： 示例代码 SmartSwipe.wrap(view) .addConsumer(new DrawerConsumer()) //抽屉效果 .setHorizontalDrawerView(buttonsViewGroup) //设置横向(左右两侧)的抽屉为同一个view（常见的侧滑显示删除按钮的功能） .setScrimColor(0x2F000000) //设置遮罩的颜色 .setShadowColor(0x80000000) //设置边缘的阴影颜色 ; 设置抽屉View 为某个方向设置抽屉view的同时，如果view不为null，则自动enable当前consumer的该方向；否则，如果view为null，则自动disable当前consumer的该方向 方法名称 参数 备注 setDrawerView int directionView view 将view设置为指定方向上的抽屉，并将direction方向enable设置为(view != null) setLeftDrawerView View view 将View设置为左侧抽屉，并将左侧的enable设置为(view != null) setRightDrawerView View view 将View设置为右侧抽屉，并将右侧的enable设置为(view != null) setTopDrawerView View view 将View设置为上侧抽屉，并将上侧的enable设置为(view != null) setBottomDrawerView View view 将View设置为下侧抽屉，并将下侧的enable设置为(view != null) setHorizontalDrawerView View view 将View设置为左右两侧的抽屉，并将左右两侧的enable设置为(view != null) setVerticalDrawerView View view 将View设置为上下两侧的抽屉，并将上下两侧的enable设置为(view != null) setAllDirectionDrawerView View view 将View设置为上下左右4侧抽屉，并将上下左右4侧的enable设置为(view != null) 除了通过代码设置抽屉View之外，还可以在xml布局文件中设置，例如demo首页的侧滑点赞控件: 注意： SmartSwipeWrapper的子view中，第1个不含app:layout_gravity属性的控件作为被wrap的主体contentView 其它view需要设置app:layout_gravity才有效 app:layout_gravity=\"top\"表示作为上侧抽屉 app:layout_gravity=\"right|left\"表示作为上下两侧的抽屉 其它设置方式同理可知 属性列表 继承自 SwipeConsumer，公共属性中的参数设置尽皆有效 getter/setter都一一对应，不赘述 变量名称 类型 取值范围 默认值 备注 mScrimColor int 颜色值 0 遮罩玻璃颜色色值，如果为0，则不显示遮罩 mShadowColor int 颜色值 0 边缘阴影颜色色值，如果为0，则不显示边缘阴影 mShadowSize int >=0 10dp 边缘阴影的尺寸，如果为0，则不显示边缘阴影 mShowScrimAndShadowOutsideContentView boolean ture/false false 遮罩和边缘阴影显示在contentView的外侧 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-11 17:17:55 "},"pages/consumers/SlidingConsumer.html":{"url":"pages/consumers/SlidingConsumer.html","title":"SlidingConsumer","keywords":"","body":"SlidingConsumer SlidingConsumer 继承自 DrawerConsumer 抽屉效果，抽屉显示在被包裹的控件下层(即contentView覆盖在抽屉之上显示) 抽屉与contentView之间可以联动，联动系数可以在0至1之间设置 如下图所示： 示例代码 SmartSwipe.wrap(view) .addConsumer(new SlidingConsumer()) .setHorizontalDrawerView(textView) .setScrimColor(0x2F000000) ; 联动系数 联动：指的是抽屉view在主体contentView侧滑时发生的关联移动 联动系数：指的是控制联动的系数 联动系数 联动效果 0 抽屉view在下层保持不动，contentView移动后逐步显示下面的抽屉view，最终完全打开时完全显示抽屉view 0~1 抽屉view与contentView同步移动，移动速率不一样，最终完全打开时完全显示抽屉view 1 抽屉view与contentView同步移动，移动速率完全相同，最终完全打开时完全显示抽屉view 抽屉view的尺寸可扩展性 当公共属性中的mOverSwipeFactor大于0时，侧滑的最大尺寸可能会大于抽屉view的尺寸，当拖动的尺寸大于抽屉view的尺寸时，出现的情况有以下几种： mOverSwipeFactor mDrawerExpandable mEdgeAffinity 效果 0 无效 无效 正常拖动，无特殊效果 >0 false true 抽屉view会一直呆在SmartSwipeWrapper的边缘不动，抽屉view与contentView之间留白 >0 false false 抽屉view会跟着contentView一起被拖动，边缘留白 >0 true 无效 抽屉view会一直呆在SmartSwipeWrapper的边缘不动，抽屉view的layout尺寸将扩展填充满contentView与边缘的空间 属性设置 继承自 DrawerConsumer，抽屉View等参数的设置与之相同 变量名称 类型 取值范围 默认值 备注 mRelativeMoveFactor float 0F~1F 0.5F 联动系数 mDrawerExpandable boolean true/false false 抽屉view的尺寸是否可扩展 mEdgeAffinity boolean true/false false 是否边缘亲和 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-09 20:55:59 "},"pages/consumers/TranslucentSlidingConsumer.html":{"url":"pages/consumers/TranslucentSlidingConsumer.html","title":"TranslucentSlidingConsumer","keywords":"","body":"TranslucentSlidingConsumer TranslucentSlidingConsumer 继承自 SlidingConsumer 侧滑透明效果，侧滑后可显示被其遮挡的view 可用作侧滑删除，也可以用来制作封面效果 如下图所示： 示例代码 //侧滑删除 SmartSwipe.wrap(view) .addConsumer(new TranslucentSlidingConsumer()) .enableHorizontal() //启用左右两侧侧滑 .addListener(new SimpleSwipeListener(){ @Override public void onSwipeOpened(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction) { //侧滑打开时，移除 ViewParent parent = wrapper.getParent(); if (parent instanceof ViewGroup) { ((ViewGroup) parent).removeView(wrapper); } //adapter.removeItem(getAdapterPosition());// 也可用作从recyclerView中移除该项 } }) ; 属性设置 继承自 SlidingConsumer， 但没有抽屉 除以下参数无效外，其它参数的设置与SlidingConsumer相同 各种setDrawerView方法 mRelativeMoveFactor mDrawerExpandable mEdgeAffinity mOverSwipeFactor 与SpaceConsumer的区别 SpaceConsumer实现的非常简洁，功能也较为简单，其作用仅仅是让被包裹的contentView可以动起来，可以用来优化交互体验 TranslucentSlidingConsumer继承自SlidingConsumer，虽然没有抽屉view，但也具备一些SlidingConsumer的功能： 在contentView或移动后的留白区域显示遮罩及边缘阴影 另外，由于TranslucentSlidingConsumer的默认滑动距离就是自身的控件尺寸 适用于完成侧滑删除效果（demo中有示例） 适用于完成侧滑封面效果（demo中有示例） TranslucentSlidingConsumer还是ActivitySlidingBackConsumer的基类 在TranslucentSlidingConsumer的基础上增加了activity透明相关的逻辑 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 10:55:57 "},"pages/consumers/ShuttersConsumer.html":{"url":"pages/consumers/ShuttersConsumer.html","title":"ShuttersConsumer","keywords":"","body":"ShuttersConsumer 百叶窗效果，侧滑后可显示被其遮挡的view 可用作侧滑删除，也可以用来制作封面效果 如下图所示： 示例代码 //侧滑删除 SmartSwipe.wrap(view) .addConsumer(new ShuttersConsumer()) .enableHorizontal() //启用左右两侧侧滑 .addListener(new SimpleSwipeListener(){ @Override public void onSwipeOpened(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction) { //侧滑打开时，移除 ViewParent parent = wrapper.getParent(); if (parent instanceof ViewGroup) { ((ViewGroup) parent).removeView(wrapper); } //adapter.removeItem(getAdapterPosition());// 也可用作从recyclerView中移除该项 } }) ; 属性设置 继承自 SwipeConsumer，公共属性中的参数设置尽皆有效 getter/setter都一一对应，不赘述 变量名称 类型 取值范围 默认值 备注 mScrimColor int 颜色值 0 遮罩玻璃颜色色值，如果为0，则不显示遮罩 mLeavesCount int 1~100 5 百叶窗叶子数 mRefreshable boolean true/false false 侧滑时是否实时刷新，为true时能实时刷新显示，对于页面中有动画，能实时显示动画；为false时只取一次view的快照，但性能损耗低 mWaitForScreenshot boolean true/false true 在获取view的快照成功前是否开始侧滑。在作为入场动画时较为有用：先设置为false，立即打开，再设置为true，然后平滑关闭 setRefreshFrameRate int 1~60 30 当mRefreshable为true时，设置自动刷新的帧率 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-11 15:57:04 "},"pages/consumers/DoorConsumer.html":{"url":"pages/consumers/DoorConsumer.html","title":"DoorConsumer","keywords":"","body":"DoorConsumer DoorConsumer 继承自 ShuttersConsumer 开门效果，侧滑后可显示被其遮挡的view 可用作侧滑删除，也可以用来制作封面效果 如下图所示： 示例代码 //侧滑删除 SmartSwipe.wrap(view) .addConsumer(new DoorConsumer()) .enableHorizontal() //启用左右两侧侧滑 .addListener(new SimpleSwipeListener(){ @Override public void onSwipeOpened(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction) { //侧滑打开时，移除 ViewParent parent = wrapper.getParent(); if (parent instanceof ViewGroup) { ((ViewGroup) parent).removeView(wrapper); } //adapter.removeItem(getAdapterPosition());// 也可用作从recyclerView中移除该项 } }) ; 属性设置 继承自 ShuttersConsumer，固定叶子数为2个，除了叶子数量设置无效外，其它参数的设置与之相同 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-15 10:26:54 "},"pages/consumers/StayConsumer.html":{"url":"pages/consumers/StayConsumer.html","title":"StayConsumer","keywords":"","body":"StayConsumer 主体contentView侧滑过程中保持不动，侧滑结束时按照手势滑动的方向和速率来确定是否开启，若开启将回调[SwipeListener][SwipeListener]的onSwipeOpen方法 可以用来实现侧滑返回 如下图所示： 示例代码 //activity侧滑返回 SmartSwipe.wrap(this) .addConsumer(new StayConsumer()) .enableAllDirections() .addListener(new SimpleSwipeListener(){ @Override public void onSwipeOpened(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction) { finish(); } }) ; 属性设置 虽然继承自 SwipeConsumer，公共属性中的参数都可设置，但由于没有任何UI呈现，大多数设置是无效的 有效的仅有 第1条: 侧滑方向的启用与锁定 第6条: 可以获取但不能设置的属性 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 11:01:21 "},"pages/consumers/BezierBackConsumer.html":{"url":"pages/consumers/BezierBackConsumer.html","title":"BezierBackConsumer","keywords":"","body":"BezierBackConsumer 主体contentView侧滑过程中保持不动，在滑动方向的边缘出现一个贝塞尔曲线背景的返回箭头，完全打开后释放将回调SwipeListener的onSwipeOpen方法 可以用来实现侧滑返回 如下图所示： 示例代码 //activity侧滑返回 SmartSwipe.wrap(this) .addConsumer(new BezierBackConsumer()) .enableAllDirections() .addListener(new SimpleSwipeListener() { @Override public void onSwipeOpened(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction) { finish(); } }) ; 属性设置 继承自 SwipeConsumer，公共属性中的参数设置尽皆有效 getter/setter都一一对应，不赘述 变量名称 类型 取值范围 默认值 备注 mSize int >0 200dp 贝塞尔曲线的尺寸（横向侧滑时代表贝塞尔曲线区域的高度，纵向侧滑时代表宽度） mOpenDistance int >0 30dp 此变量在父类中用作从关闭状态到打开状态所需的侧滑距离，此处赋予另一个功能：作为贝塞尔曲线的最大显示厚度 mColor int 颜色值 0 此颜色值alpha部分无效，只取RGB部分，alpha根据侧滑进度计算：alpha = 0xFF * mProgress, mProgress有效范围为[0.2, 0.8] mArrowSize int >0 4dp 箭头尺寸的一半，例如:左侧侧滑时，箭头的高度像素值 = 2 * mArrowSize mArrowColor 颜色值 >0 0xFFF2F2F2 此颜色值alpha部分无效，只取RGB部分，alpha根据侧滑进度计算：alpha = 0xFF * mProgress, mProgress有效范围为[0, 1] mCenter boolean true/false false 是否固定居中显示，为false时中心点为手指按下时的位置。例如：左侧侧滑时中心的坐标为(0, pointerDownY) Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 14:39:49 "},"pages/consumers/ActivitySlidingBackConsumer.html":{"url":"pages/consumers/ActivitySlidingBackConsumer.html","title":"ActivitySlidingBackConsumer","keywords":"","body":"ActivitySlidingBackConsumer 仿微信侧滑返回效果 专为完成Activity的侧滑而做的一种效果，支持与前一个Activity的联动效果 如下图所示： 示例代码 //activity侧滑返回 SmartSwipe.wrap(this) .addConsumer(new ActivitySlidingBackConsumer(this)) .setRelativeMoveFactor(0.5F) .enableAllDirections() ; 属性设置 继承自 TranslucentSlidingConsumer，属性设置与之相同 同样支持联动系数设置，不过指的是前一个Activity与当前activity的联动，联动效果等同于SlidingConsumer中抽屉view的联动效果 注意事项 支持的最低android API版本为21 (Lollipop)，即android 5.0 如何兼容5.0以下系统版本？ Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 14:57:11 "},"pages/consumers/ActivityShuttersBackConsumer.html":{"url":"pages/consumers/ActivityShuttersBackConsumer.html","title":"ActivityShuttersBackConsumer","keywords":"","body":"ActivityShuttersBackConsumer 百叶窗式侧滑返回，专为完成Activity的侧滑返回而做的一种效果 如下图所示： 示例代码 //activity侧滑返回 SmartSwipe.wrap(this) .addConsumer(new ActivityShuttersBackConsumer(this)) .setScrimColor(0x7F000000) .enableAllDirections() ; 属性设置 继承自 ShuttersConsumer，属性设置与之相同 注意事项 支持的最低android API版本为21 (Lollipop)，即android 5.0 如何兼容5.0以下系统版本？ Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 14:55:44 "},"pages/consumers/ActivityDoorBackConsumer.html":{"url":"pages/consumers/ActivityDoorBackConsumer.html","title":"ActivityDoorBackConsumer","keywords":"","body":"ActivityDoorBackConsumer 开门式侧滑返回，专为完成Activity的侧滑返回而做的一种效果 如下图所示： 示例代码 //activity侧滑返回 SmartSwipe.wrap(this) .addConsumer(new ActivityDoorBackConsumer(this)) .setScrimColor(0x7F000000) .enableAllDirections() ; 属性设置 继承自 DoorConsumer，属性设置与之相同 注意事项 支持的最低android API版本为21 (Lollipop)，即android 5.0 如何兼容5.0以下系统版本？ Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 14:55:28 "},"pages/SwipeListener.html":{"url":"pages/SwipeListener.html","title":"侧滑监听","keywords":"","body":"SwipeListener 可以通过swipeConsumer.addListener(listener)来监听该SwipeConsumer对象的运行状态 可以对同一个SwipeConsumer对象多次调用addListener(listener)来添加多个监听对象，并按照添加的顺序执行回调 接口定义 /** * listen swipe state of {@link SwipeConsumer} via {@link SwipeConsumer#addListener(SwipeListener)} * @author billy.qi * @see SimpleSwipeListener */ public interface SwipeListener { void onConsumerAttachedToWrapper(SmartSwipeWrapper wrapper, SwipeConsumer consumer); void onConsumerDetachedFromWrapper(SmartSwipeWrapper wrapper, SwipeConsumer consumer); void onSwipeStateChanged(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int state, int direction, float progress); void onSwipeStart(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction); void onSwipeProcess(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction, boolean settling, float progress); void onSwipeRelease(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction, float progress, float xVelocity, float yVelocity); void onSwipeOpened(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction); void onSwipeClosed(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction); } Tips SmartSwipe为SwipeListener接口提供了一个空实现类：SimpleSwipeListener， 只需要个别状态回调时可继承此类，从而使得代码更简洁 回调顺序 手势打开/关闭onSwipeStart onSwipeStateChanged (state = 1) onSwipeProcess(0个或多个, settling=false) onSwipeRelease onSwipeOpened(这个open状态回调需要满足2个条件：抬起手指时滑动距离>=mOpenDistance、释放模式为RELEASE_MODE_AUTO_CLOSE) onSwipeStateChanged (state = 2) onSwipeProcess(0个或多个, settling=true) onSwipeStateChanged (state = 0) onSwipeOpened/onSwipeClosed 自动打开/关闭onSwipeStart onSwipeStateChanged (state = 2) onSwipeProcess(多个, settling=true) onSwipeStateChanged (state = 0) onSwipeOpened/onSwipeClosed 简单示例 SmartSwipe.wrap(SwipeBackBezierConsumerActivity.this) .addConsumer(new BezierBackConsumer()) .enableLeft() .addListener(new SimpleSwipeListener() { @Override public void onSwipeOpened(SmartSwipeWrapper wrapper, SwipeConsumer consumer, int direction) { finish(); } }) Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-12 15:56:20 "},"pages/SwipeDistanceCalculator.html":{"url":"pages/SwipeDistanceCalculator.html","title":"侧滑距离计算器","keywords":"","body":"SwipeDistanceCalculator 侧滑距离计算器 默认情况下，用户手指移动的距离就是UI需要呈现的侧滑距离。 某些情况下我们并不想这样，比如要实现阻力滑动效果，实际UI展示的移动距离占手指移动距离的60%。 这时我们就需要在侧滑事件触发移动后，在consumer消费这个侧滑距离之前，对它进行一次加工，并将加工后的距离交给consumer去消费：展示到UI上。 接口定义如下： public interface SwipeDistanceCalculator { /** * 计算侧滑距离 * @param swipeDistance 侧滑的距离 * @param progress 当前侧滑进度，其取值范围为 [0, 1 + consumer.getOverSwipeFactor())] * @return 展示在UI上的侧滑距离 */ int calculateSwipeDistance(int swipeDistance, float progress); /** * 作为calculateSwipeDistance的反向运算，这个方法是要计算使用这个计算器后，UI从关闭状态到打开状态，所需侧滑的距离 * @param openDistance 不使用计算器时，打开状态所需侧滑的距离 * @return 从关闭状态到打开状态所需侧滑的距离 */ int calculateSwipeOpenDistance(int openDistance); } SmartSwipe中内置了一个带阻力效果的计算器 public class ScaledCalculator implements SwipeDistanceCalculator { //阻力系数 private float mScale; public ScaledCalculator(float scale) { if (scale Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-09 19:01:18 "},"pages/directions.html":{"url":"pages/directions.html","title":"侧滑方向","keywords":"","body":"Swipe Direction SmartSwipe只处理上下左右4个方向的侧滑事件，在SmartSwipe中，对滑动方向的定义只能是下表方向的一种或者几种的组合 方向 常量名称 取值 备注 无 SwipeConsumer.DIRECTION_NONE 0x0 无方向 左 SwipeConsumer.DIRECTION_LEFT 0x1 从左向右的侧滑 右 SwipeConsumer.DIRECTION_RIGHT 0x2 从右向左的侧滑 上 SwipeConsumer.DIRECTION_TOP 0x4 从上向下的侧滑 下 SwipeConsumer.DIRECTION_BOTTOM 0x8 从下向上的侧滑 为了方便，已经内置了3种组合对应的常量 方向 常量名称 取值 备注 水平方向(左&右) SwipeConsumer.DIRECTION_HORIZONTAL 0x3 左右2个方向的侧滑 垂直方向(上&下) SwipeConsumer.DIRECTION_VERTICAL 0x12 上下2个方向的侧滑 全部(上&下&左&右) SwipeConsumer.DIRECTION_ALL 0x15 上下左右4个方向的侧滑 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-08 14:24:24 "},"pages/releaseMode.html":{"url":"pages/releaseMode.html","title":"Release处理方式","keywords":"","body":"Release处理方式 不同的侧滑功能，在用户拖动结束抬起手指时的处理方式可能会不同。 SwipeConsumer中定义了以下几种Release处理方式，可以组合使用 名称 常量 取值 备注 无 SwipeConsumer.RELEASE_MODE_NONE 0x0 不管侧滑进度如何，释放时（手指抬起时）均保持不动 自动关闭 SwipeConsumer.RELEASE_MODE_AUTO_CLOSE 0x1 不管拉动多少距离，释放后自动关闭 自动开启 SwipeConsumer.RELEASE_MODE_AUTO_OPEN 0x2 不管拉动多少距离，释放后自动打开至open状态(mProgress == 1) 自动开启&关闭 SwipeConsumer.RELEASE_MODE_AUTO_OPEN_CLOSE 0x3 优先按照释放时的速度方向判断开启开始关闭，若速率为0，则按照侧滑进度是否过半(mProgress > 0.5F)来决定自动开启还是关闭 保持开启 SwipeConsumer.RELEASE_MODE_HOLE_OPEN 0x4 如果释放时侧滑进度已满(mProgress >= 1),则保持或自动回弹到开启状态 示例讲解： 在SmartSwipeRefresh中封装下拉刷新功能时，使用了RELEASE_MODE_AUTO_CLOSE 和 RELEASE_MODE_HOLE_OPEN的组合 setReleaseMode(SwipeConsumer.RELEASE_MODE_AUTO_CLOSE | SwipeConsumer.RELEASE_MODE_HOLE_OPEN) 原因是，下拉刷新需求决定了：需要手动拉满(mProgress >= 1)才能执行刷新，其它情况下都是自动收回(自动关闭)。所以，需要用自动关闭和保持开启2个模式的组合来完成释放时的处理 注：如果拉动越界了还需要等待自动回弹到开启状态(mProgress == 1)时才执行刷新 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-09 14:38:52 "},"pages/SmartSwipeBack.html":{"url":"pages/SmartSwipeBack.html","title":"全局侧滑返回","keywords":"","body":"SmartSwipeBack 实现全局Activity侧滑返回 公共参数说明 application: Application对象，用于注册全局activity生命周期监听 edgeSize：边缘触发区域尺寸像素值（dp需转换为px），若设置为0，则表示整个activity区域都可触发 direction：开启侧滑的方向，可设置为上下左右中的一个或多个，其取值可参考侧滑方向，为0则不会触发侧滑 filter: Activity过滤器，用于过滤确定对哪些activity进行侧滑返回的封装，若为null，则不过滤，对所有activity都执行侧滑返回的封装 Activity过滤器接口定义如下： public interface ActivitySwipeBackFilter { /** * Determine whether the activity parameter should swipe back * @param activity The activity to wrap or not * @return true: need to wrap with swipe back, false: do not wrap */ boolean onFilter(Activity activity); } 可以创建一个它的实现类来为SmartSwipeBack添加过滤，例如： //主Activity不需要侧滑返回功能，其它Activity都采用仿微信侧滑返回效果 SmartSwipeBack.activitySlidingBack(application, new SmartSwipeBack.ActivitySwipeBackFilter() { @Override public boolean onFilter(Activity activity) { //根据传入的activity，返回true代表需要侧滑返回；false表示不需要侧滑返回 return !(activity instanceof MainActivity); } }); 已封装的5种全局侧滑返回方案 仿手机QQ侧滑返回 //activity保持不动，根据最后释放时的滑动速率来确定是否关闭activity SmartSwipeBack.activityStayBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter, int edgeSize, int direction) //在上一个方法的基础上，触发区域采用默认设置：左侧边缘20dp范围内 SmartSwipeBack.activityStayBack(this, activitySwipeBackFilter); 仿微信侧滑返回效果 //添加全局透明侧滑返回(5.0以下版本的设备上使用activityStayBack) // scrimColor: 玻璃颜色，显示在前一个activity之上的半透明遮罩颜色值, 默认为透明色 // shadowColor: 在当前activity移动的边缘显示的阴影颜色，默认为透明色 // shadowSize: shadowColor显示的大小像素值，默认为10dp // factor: 关联移动系数 // 0: 前一个activity保持不动，当前activity随着手势滑动而平移，移动后可透视前一个activity // (0,1): 前一个activity与当前activity有关联移动效果，具体效果如上图所示 // 1: 前一个activity跟随当前activity一起平移（类似于ViewPager的默认平移效果） SmartSwipeBack.activitySlidingBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter , int edgeSize, int scrimColor, int shadowColor, int shadowSize , float factor, int direction) //在上一个方法的基础上，部分参数采用默认设置： // 触发区域：左侧边缘20dp // 遮罩玻璃颜色值: Color.TRANSPARENT // 边缘阴影颜色值: 0x80000000 // 边缘阴影尺寸: 10dp SmartSwipeBack.activitySlidingBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter, float factor) //在上一个方法的基础上，关联移动系数采用默认设置：0.5F SmartSwipeBack.activitySlidingBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter) 仿MIUI系统贝塞尔曲线侧滑返回 // size: 尺寸大小（水平方向侧滑时指的是贝塞尔曲线区域的高度，垂直方向侧滑时指的是贝塞尔曲线区域的宽度）单位为px(dp需转换为px) // thickness: 侧滑拉满时贝塞尔曲线区域的厚度（水平方线侧滑时指的是最大宽度，垂直方向侧滑时指的是最大高度）单位为px(dp需转换为px) // color: 贝塞尔曲线和屏幕边缘构成的区域填充色 // arrowColor: 贝塞尔曲线区域内箭头的颜色 SmartSwipeBack.activityBezierBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter , int edgeSize, int size, int thickness, int color, int arrowColor, int direction) //在上一个方法的基础上，部分参数采用默认值： // thickness: 30dp // size: 200dp // 触发方向：左侧 // 触发区域范围需设置 SmartSwipeBack.activityBezierBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter, int edgeSize) //在上一个方法的基础上，触发区域默认值设置为：左侧20dp范围内 SmartSwipeBack.activityBezierBack(this, activitySwipeBackFilter); 开门式侧滑返回 支持的最低api等级为21，即android 5.0 如何兼容5.0以下版本？ 不支持含有SurfaceView/GLSurfaceView/TextureView/VideoView等控件的页面（将会在这些view的区域显示透明），如果app内有页面含有这些控件，需要在ActivitySwipeBackFilter中将其过滤 // scrimColor: 玻璃颜色，即开门过程中透视前一个activity时的遮罩颜色 // refreshable: 是否实时刷新，若页面有动画等内容时，需要设置为true以取得更好的用户体验，否则可设置为false以获得更好的性能 SmartSwipeBack.activityDoorBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter , int direction, int edgeSize, int scrimColor, boolean refreshable) //在上一个方法的基础上，使用的默认值为： // scrimColor: 0x80000000 // refreshable: true // 触发区域默认值设置为：左侧20dp范围内 SmartSwipeBack.activityDoorBack(this, activitySwipeBackFilter); 百叶窗式侧滑返回 支持的最低api等级为21，即android 5.0 如何兼容5.0以下版本？ 不支持含有SurfaceView/GLSurfaceView/TextureView/VideoView等控件的页面（将会在这些view的区域显示透明），如果app内有页面含有这些控件，需要在ActivitySwipeBackFilter中将其过滤 // scrimColor: 玻璃颜色，即开门过程中透视前一个activity时的遮罩颜色 // refreshable: 是否实时刷新，若页面有动画等内容时，需要设置为true以取得更好的用户体验，否则可设置为false以获得更好的性能 SmartSwipeBack.activityShuttersBack(Application application, SmartSwipeBack.ActivitySwipeBackFilter filter , int direction, int edgeSize, int scrimColor, boolean refreshable) { //在上一个方法的基础上，使用的默认值为： // scrimColor: 0x80000000 // refreshable: true // 触发区域默认值设置为：左侧20dp范围内 SmartSwipeBack.activityShuttersBack(this, activitySwipeBackFilter); 兼容5.0以下系统版本 由于采用了activity透明的方式来透视前一个activity，在5.0以下版本系统上存在兼容性问题，导致仿微信侧滑返回、开门式侧滑返回和百叶窗式侧滑返回只在5.0以上版本的设备生效。 由于5.0以下版本的设备占比已经较少，与其采用会修改主题为透明并在onCreated中在变为不透明等较为复杂的方案，不如分别为5.0以上及以下的采用不同的侧滑返回方案 示例代码： if (Build.VERSION.SDK_INT 注：仿微信侧滑返回(activitySlidingBack)方案在5.0以下默认使用仿手机QQ的侧滑方案(activityStayBack) 自定义全局侧滑返回方案 如果以上封装的方案并不能满足您当前的实际需求，可以仿照这些封装的实现方式来自定义一个更合适当前需求的侧滑方案 首先，需要定义一个SwipeBackConsumerFactory接口的实现类，用于为不同的activity创建侧滑返回功能对应的SwipeConsumer public interface SwipeBackConsumerFactory { /** * Create SwipeConsumer to do swipe back business for activity * @param activity activity to wrap with swipe back * @return SwipeConsumer */ SwipeConsumer createSwipeBackConsumer(Activity activity); } 然后，在合适的位置调用以下方法， 传入自定义的SwipeBackConsumerFactory对象，将其应用于全局activity SmartSwipeBack.activityBack(Application application, SwipeBackConsumerFactory factory, ActivitySwipeBackFilter filter) Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-15 11:02:15 "},"pages/SmartSwipeRefresh.html":{"url":"pages/SmartSwipeRefresh.html","title":"下拉刷新","keywords":"","body":"SmartSwipeRefresh SmartSwipeRefresh支持下拉刷新和上拉加载更多，并且支持纵向模式和横向模式（左侧右拉刷新、右侧左拉加载更多），支持禁用刷新或者禁用加载更多。 下拉刷新(及上拉加载更多)是DrawerConsumer及SlidingConsumer的一种应用，SmartSwipeRefresh使用它们来分别支持不同的下拉刷新模式，包括： drawerMode: （封装使用的是DrawerConsumer）抽屉模式，下拉时，被刷新的主体不动，刷新控件显示在主体上方拖动显示 behindMode: （封装使用的是SlidingConsumer）刷新控件被固定在后面，下拉时，被刷新的主体被拖动，从而显示在后面的刷新控件 scaleMode: （封装使用的是SlidingConsumer） 缩放模式(伪)，下拉时，被刷新的主体向下移动，刷新控件的中间位置始终在主体下拉后的空白区域的正中间 translateMode: （封装使用的是SlidingConsumer）平移模式，下拉时，被刷新的主体与刷新控件一起移动 效果演示 模式 mDrawerExpandable mEdgeAffinity 效果图 备注 drawerMode - - 默认值：mOverSwipeFactor=0.5F drawerMode - - 手动设置为不可越界拖动:setOverSwipeFactor(0); behindMode false false 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=0F behindMode false true 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=0F behindMode true 无效 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=0F scaleMode false false 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=0.5F scaleMode false true 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=0.5F scaleMode true 无效 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=0.5F translateMode false false 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=1F translateMode false true 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=1F translateMode true 无效 默认值：mOverSwipeFactor=0.5FmRelativeMoveFactor=1F 示例代码 为某个view添加下拉刷新功能的示例代码如下: SmartSwipeRefresh.SmartSwipeRefreshDataLoader loader = new SmartSwipeRefresh.SmartSwipeRefreshDataLoader() { @Override public void onRefresh(final SmartSwipeRefresh ssr) { //加载刷新数据 loadRefreshData(new Callback() { void success() { ssr.finished(true); //刷新完成后，如果数据不足一页，可以提前设置已加载完成的状态 boolean loadCompleted = false; ssr.setNoMoreData(loadCompleted); } void failed() { ssr.finished(false); } }) } @Override public void onLoadMore(final SmartSwipeRefresh ssr) { //加载下一页数据 loadMoreData(new Callback() { void success() { ssr.finished(true); // 是否已全部加载完成 boolean loadCompleted = true; ssr.setNoMoreData(loadCompleted); } void failed() { ssr.finished(false); } }) } }; SmartSwipeRefresh.behindMode(findViewById(R.id.container), false).setDataLoader(loader); 基本使用 使用默认的header和footer (ClassicHeader和ClassicFooter) //xxxMode第二个参数为false，表示工作方向为纵向：下拉刷新&上拉加载更多 //如果第二个参数设置为true，则表示工作方向为横向：右拉刷新&左拉加载更多 SmartSwipeRefresh.drawerMode(view, false).setDataLoader(loader); SmartSwipeRefresh.behindMode(view, false).setDataLoader(loader); SmartSwipeRefresh.scaleMode(view, false).setDataLoader(loader); SmartSwipeRefresh.translateMode(view, false).setDataLoader(loader); 全局使用自定义的Header和Footer构造器：SmartSwipeRefreshViewCreator 实现SmartSwipeRefreshViewCreator接口，接口的定义如下：/** * creator of {@link SmartSwipeRefreshHeader} and {@link SmartSwipeRefreshFooter} */ public interface SmartSwipeRefreshViewCreator { /** * create the refresh header view * @param context context * @return header */ SmartSwipeRefreshHeader createRefreshHeader(Context context); /** * create the refresh footer view * @param context context * @return footer */ SmartSwipeRefreshFooter createRefreshFooter(Context context); } 将构造器设置为全局使用 SmartSwipeRefresh.setDefaultRefreshViewCreator(creator); 使用全局构造器给指定的View添加下拉刷新功能(与使用默认的header和footer的方式一样)SmartSwipeRefresh.drawerMode(view, false).setDataLoader(loader); SmartSwipeRefresh.behindMode(view, false).setDataLoader(loader); SmartSwipeRefresh.scaleMode(view, false).setDataLoader(loader); SmartSwipeRefresh.translateMode(view, false).setDataLoader(loader); 为当前view使用特殊的自定义header和footer //xxxMode的第三个参数为false，表示不使用全局和默认的header和footer SmartSwipeRefresh.drawerMode(view, false, false).setDataLoader(loader).setHeader(header).setFooter(footer); SmartSwipeRefresh.behindMode(view, false, false).setDataLoader(loader).setHeader(header).setFooter(footer); SmartSwipeRefresh.scaleMode(view, false, false).setDataLoader(loader).setHeader(header).setFooter(footer); SmartSwipeRefresh.translateMode(view, false, false).setDataLoader(loader).setHeader(header).setFooter(footer); 数据加载回调 /** * The refresh data loader * When refresh or load more event emits, its methods will be called */ public interface SmartSwipeRefreshDataLoader { /** * Called when {@link SmartSwipeRefreshHeader} swipe released and it has been fully swiped * @param ssr {@link SmartSwipeRefresh} */ void onRefresh(SmartSwipeRefresh ssr); /** * Called when {@link SmartSwipeRefreshFooter} swipe released and it has been fully swiped * @param ssr {@link SmartSwipeRefresh} */ void onLoadMore(SmartSwipeRefresh ssr); } 在侧滑事件符合下拉刷新或上拉加载更多时，会回调对应的onRefresh/onLoadMore方法，并且header和footer开始播放加载中的动画 SmartSwipeRefreshDataLoader中加载完数据时，需要调用ssr.finished(success)来告诉SmartSwipeRefresh加载过程已结束，开始播放结束动画 如果数据已加载完成，可以通过设置ssr.setNoMoreData(true)来显示全部加载完成的状态，并且继续下拉时不再触发网络请求（不会回调onLoadMore方法） 其它功能 自动刷新smartSwipeRefresh.startRefresh(); //立即开启自动刷新 自动加载更多smartSwipeRefresh.startLoadMore(); 禁用刷新功能smartSwipeRefresh.disableRefresh(); 禁用加载更多smartSwipeRefresh.disableLoadMore(); 获取SwipeConsumer对象，从而可以使用更多相关api，例如：SmartSwipeRefresh.scaleMode(findViewById(R.id.container), false) .setDataLoader(dataLoader) .getSwipeConsumer() //获取SwipeConsumer .as(SlidingConsumer.class) //类型转换 .setEdgeAffinity(true); //刷新控件在下拉空间超出控件大小时紧贴边缘，不随被刷新主体的拖动而继续移动 自定义Header和Footer SmartSwipe内置了布局较为简洁的ClassicHeader和ClassicFooter。 可以仿照ClassicHeader和ClassicFooter来创建自定义的header和footer 自定义header需要实现接口： SmartSwipeRefreshHeader 自定义footer需要实现接口： SmartSwipeRefreshFooter 接口定义及解释如下： private interface RefreshView { /** * 获取刷新控件的UI布局，不能为null */ View getView(); /** * 初始化回调方法，在RefreshView作为header或footer被添加到{@link DrawerConsumer} or {@link SlidingConsumer}之前被调用 * @param horizontal true: 工作方向为横向 * false: 工作方向为纵向 */ void onInit(boolean horizontal); /** * 开始工作时回调 */ void onStartDragging(); /** * 工作过程中回调 * @param dragging 是否用户手势拖动 * @param progress 进度，关闭状态为0，完全打开状态为1，取值范围：[0F, 1F + overSwipeFactor]，超过1时是否会有回弹效果 */ void onProgress(boolean dragging, float progress); /** * 当{@link SmartSwipeRefresh#finished(boolean)} 调用时回调此方法 * @param success 数据加载是否成功 * @return 延迟多少毫秒开始执行收回的动画（等待RefreshView动画结束并显示加载成功状态相关的UI） */ long onFinish(boolean success); /** * 开始加载数据，展示加载数据时的相关UI动画 */ void onDataLoading(); } /** header需要实现的接口 */ public interface SmartSwipeRefreshHeader extends RefreshView { } /** footer需要实现的接口 */ public interface SmartSwipeRefreshFooter extends RefreshView { /** * 给footer打标记，表示数据已全部加载完成，展示相关UI * @param noMoreData true: 已全部加载完成 false: 未加载完成，下次上拉还需要继续执行下一页数据的加载工作 */ void setNoMoreData(boolean noMoreData); } 创建好header和footer之后，再创建一个SmartSwipeRefreshViewCreator为全局下拉刷新功能创建自定义的刷新控件 SmartSwipeRefresh.setDefaultRefreshViewCreator(new SmartSwipeRefreshViewCreator() { @Override public SmartSwipeRefreshHeader createRefreshHeader(Context context) { return new MyHeader(context); } @Override public SmartSwipeRefreshFooter createRefreshFooter(Context context) { return new MyFooter(context); } }); Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-10 16:30:05 "},"pages/SwipeConsumerExclusiveGroup.html":{"url":"pages/SwipeConsumerExclusiveGroup.html","title":"互斥组","keywords":"","body":"SwipeConsumerExclusiveGroup 管理一组SwipeConsumer,在这个组内的SwipeConsumer打开状态是互斥的：同时只能有0个或1个SwipeConsumer处于打开状态，打开一个，其它的都将自动关闭 构造方法 /** * 创建一个SwipeConsumerExclusiveGroup，指定{{book.baseName}}自动关闭时是否平滑关闭 * @param smooth 是否平滑关闭(true:平滑动画关闭, false: 立即关闭) */ public SwipeConsumerExclusiveGroup(boolean smooth) { this.smooth = smooth; } public SwipeConsumerExclusiveGroup() { this.smooth = true; } 将SwipeConsumer添加到SwipeConsumerExclusiveGroup组中 consumer.addToExclusiveGroup(group); //或者 group.add(consumer); 将一个SwipeConsumer从组内移除 group.remove(consumer); 手动将组内的所有SwipeConsumer全部关闭 group.markNoCurrent(); 清除组内的所有SwipeConsumer group.clear(); 锁定其它的consumer 若当前某个consumer已打开，在关闭它之前，其它SwipeConsumer无法开启 group.setLockOther(true); Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-11 17:20:33 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"侧滑 上下左右4个方向的手势滑动 侧滑事件 触发侧滑的事件，整个过程从MotionEvent.ACTION_DOWN到MotionEvent.ACTION_UP（或MotionEvent.ACTION_CANCEL）的整个过程 overSwipeFactor float类型，打开SwipeUI后能越界继续拖动的系数 progress 当前SwipeUI的打开完成度，float类型，取值范围为(0 ~ 1 + overSwipeFactor)，关闭状态为0，打开状态为1 Copyright © qibilly.com 2019 all right reserved，powered by Gitbook最后修改时间： 2019-07-11 18:38:57 "}}